#![feature(proc_macro_hygiene, decl_macro)]
#![feature(plugin)]
#![feature(type_ascription)]

///
/// A werserver connecting the search engine
/// The api is a horrible mess, don't use it.
///

#[macro_use]
extern crate rocket;
#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate measure_time;

#[cfg(test)]
mod tests;

use chashmap::CHashMap;
use flate2::read::GzEncoder;
// use multipart::server::{
//     save::{Entries, SaveResult::*},
//     Multipart,
// };
use rocket::{
    fairing,
    http::{ContentType, Status},
    request::LenientForm,
    response::{self, status::Custom, Responder, Response},
    Request,
};
use rocket_contrib::json::Json;
use std::{
    collections::HashMap,
    io::{prelude::*, Cursor},
};
use veloci::{
    doc_store::*,
    error::VelociError,
    persistence::{self, Persistence},
    query_generator, search, search_field,
};

lazy_static! {
    static ref PERSISTENCES: CHashMap<String, Persistence> = CHashMap::default();
    // static ref SHARDS: CHashMap<String, Shards> = { CHashMap::default() };
}

#[derive(Debug)]
struct SearchResult(search::SearchResultWithDoc);
// struct SearchErroro(VelociError);

#[derive(Debug)]
struct SuggestResult(search_field::SuggestFieldResult);

impl<'r> Responder<'r> for SearchResult {
    fn respond_to(self, _req: &Request) -> response::Result<'r> {
        Response::build()
            .header(ContentType::JSON)
            .sized_body(Cursor::new(serde_json::to_string(&self.0).unwrap()))
            .ok()
    }
}
// impl<'r> Responder<'r> for SearchErroro {
//     fn respond_to(self, _req: &Request) -> response::Result<'r> {
//         let formatted_error: String = format!("{:?}", &self.0);
//         Response::build()
//             .header(ContentType::JSON)
//             .sized_body(Cursor::new(serde_json::to_string(&json!({ "error": formatted_error })).unwrap()))
//             .ok()
//     }
// }

impl<'r> Responder<'r> for SuggestResult {
    fn respond_to(self, _req: &Request) -> response::Result<'r> {
        Response::build()
            .header(ContentType::JSON)
            .sized_body(Cursor::new(serde_json::to_string(&self.0).unwrap()))
            .ok()
    }
}

#[derive(FromForm, Serialize, Deserialize)]
struct QueryParams {
    //TODO serialize directly into SearchQueryGeneratorParameters
    query: String,
    top: Option<usize>,
    skip: Option<usize>,
    levenshtein: Option<usize>,
    levenshtein_auto_limit: Option<usize>,
    fields: Option<String>,
    facets: Option<String>,
    stopword_lists: Option<String>,
    stopwords: Option<String>,
    facetlimit: Option<usize>,
    /// e.g. myfield->2.0,otherfield->0.5
    boost_fields: Option<String>,
    boost_terms: Option<String>,
    operator: Option<String>,
    select: Option<String>,
    why_found: Option<bool>,
    boost_queries: Option<String>,
    phrase_pairs: Option<String>,
    explain: Option<String>,
    text_locality: Option<String>,
    filter: Option<String>,
}

// struct MyParam {
//     key: String,
//     value: usize
// }

// use rocket::request::FromParam;
// use rocket::http::RawStr;

// impl FromParam for MyParam {
//     type Error = RawStr;

//     fn from_param(param: RawStr) -> Result<Self, Self::Error> {
//         let (key, val_str) = match param.find(':') {
//             Some(i) if i > 0 => (&param[..i], &param[(i + 1)..]),
//             _ => return Err(param)
//         };

//         if !key.chars().all(|c| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
//             return Err(param);
//         }

//         val_str.parse().map(|value| {
//             MyParam {
//                 key: key,
//                 value: value
//             }
//         }).map_err(|_| param)
//     }
// }

// #[get("/test")]
// fn test() -> String {
//     "0.5".to_string()
// }

fn query_param_to_vec(name: Option<String>) -> Option<Vec<String>> {
    // TODO Replace with FromForm ? directly in QueryParams
    name.map(|el| el.split(',').map(|f| f.to_string()).collect())
}

fn ensure_database(database: &String) -> Result<(), VelociError> {
    if !PERSISTENCES.contains_key(database) {
        PERSISTENCES.insert(database.clone(), persistence::Persistence::load(database.clone())?);
    }
    Ok(())
}

// fn ensure_shard(database: &String) -> Result<(), VelociError> {
//     if !SHARDS.contains_key(database) {
//         SHARDS.insert(database.clone(), Shards::load(database.clone())?);
//         // SHARDS.insert(database.clone(), Shards::load(database.clone(), 1)?);
//     }
//     Ok(())
// }

#[get("/version")]
fn version() -> String {
    "0.7".to_string()
}

fn search_in_persistence(persistence: &Persistence, request: veloci::search::Request) -> Result<SearchResult, VelociError> {
    // info!("Searching ... ");
    let select = request.select.clone();
    let hits = {
        info_time!("Searching ... ");
        search::search(request, persistence)?
    };
    info!("Loading Documents... ");
    let doc = {
        info_time!("Loading Documents...  ");
        SearchResult(search::to_search_result(persistence, hits, &select))
    };
    debug!("Returning ... ");
    Ok(doc)
}

fn excute_suggest(persistence: &Persistence, struct_body: search::Request, _flame: bool) -> Result<SuggestResult, VelociError> {
    info_time!("search total");
    info!("Suggesting ... ");
    let hits = search_field::suggest_multi(persistence, struct_body)?;
    debug!("Returning ... ");
    Ok(SuggestResult(hits))
}

#[post("/<database>/search", format = "application/json", data = "<request>")]
fn search_post(database: String, request: Json<search::Request>) -> Result<SearchResult, VelociError> {
    ensure_database(&database)?;
    let persistence = PERSISTENCES.get(&database).unwrap();

    search_in_persistence(&persistence, request.0)
}

#[get("/<database>/_idtree/<id>")]
fn get_doc_for_id_tree(database: String, id: u32) -> Json<serde_json::Value> {
    ensure_database(&database).unwrap();
    let persistence = PERSISTENCES.get(&database).unwrap();
    let all_fields = persistence.metadata.get_all_fields();

    Json(search::read_data(&persistence, id, &all_fields).unwrap())
}

#[get("/<database>/_id/<id>")]
fn get_doc_for_id_direct(database: String, id: u32) -> Json<serde_json::Value> {
    // let persistence = PERSISTENCES.get(&database).unwrap();
    // let fields = persistence.get_all_fields();
    // let tree = search::get_read_tree_from_fields(&persistence, &fields);
    ensure_database(&database).unwrap();
    let persistence = PERSISTENCES.get(&database).unwrap();

    let f = persistence.get_mmap_handle("data").unwrap(); // TODO No unwrapo
    let doc_store = DocLoader::open(f.as_ref());
    Json(serde_json::from_str(&doc_store.get_doc(id).unwrap()).unwrap())
}

// #[get("/<database>/<id>")]
// fn get_doc_for_id(database: String, id: u32) -> Result<serde_json::Value, VelociError> {
//     let persistence = PERSISTENCES.get(&database).unwrap();
//     let fields = persistence.get_all_fields();
//     let tree = search::get_read_tree_from_fields(&persistence, &fields);
//     search::read_tree(&persistence, 25000, &tree)
// }

fn search_from_query_params(database: String, params: QueryParams) -> Result<SearchResult, Custom<String>> {
    ensure_database(&database).map_err(search_error_to_rocket_error)?;
    let persistence = PERSISTENCES.get(&database).unwrap();

    let facets: Option<Vec<String>> = query_param_to_vec(params.facets);
    let stopword_lists: Option<Vec<String>> = query_param_to_vec(params.stopword_lists);
    let stopwords: Option<Vec<String>> = query_param_to_vec(params.stopwords);
    let fields: Option<Vec<String>> = query_param_to_vec(params.fields);

    let boost_fields: Option<Result<HashMap<String, f32>, _>> = query_param_to_vec(params.boost_fields).map(|mkay| {
        mkay.into_iter()
            .map(|el| {
                let field_n_boost = el.split("->").collect::<Vec<&str>>();

                let val = field_n_boost[1]
                    .parse::<f32>()
                    .map_err(|_err| Custom(Status::BadRequest, "Could not parse boost value as float".to_string()))?;
                Ok((field_n_boost[0].to_string(), val))
            })
            .collect()
    });
    // .unwrap_or(Ok(HashMap::default()));

    let boost_terms: Option<HashMap<String, f32>> = query_param_to_vec(params.boost_terms).map(|mkay| {
        mkay.into_iter()
            .map(|el| {
                let field_n_boost = el.split("->").collect::<Vec<&str>>();
                (field_n_boost[0].to_string(), field_n_boost.get(1).map(|el| el.parse::<f32>().unwrap()).unwrap_or(2.0))
            })
            .collect()
    });
    // .unwrap_or(HashMap::default());

    let mut q_params = query_generator::SearchQueryGeneratorParameters {
        search_term: params.query.to_string(),
        top: params.top,
        skip: params.skip,
        ignore_case: None,
        operator: params.operator,
        levenshtein: params.levenshtein,
        levenshtein_auto_limit: params.levenshtein_auto_limit,
        facetlimit: params.facetlimit,
        why_found: params.why_found,
        phrase_pairs: params.phrase_pairs.map(|el| el.to_lowercase() == "true"),
        text_locality: params.text_locality.map(|el| el.to_lowercase() == "true"),
        facets,
        stopword_lists,
        stopwords: stopwords.map(|list| list.into_iter().collect()),
        fields,
        boost_fields: boost_fields.transpose()?,
        boost_terms,
        explain: params.explain.map(|el| el.to_lowercase() == "true"),
        boost_queries: None,
        select: None,
        filter: params.filter,
        parser_options: None,
        filter_parser_options: None,
    };

    if let Some(el) = params.boost_queries {
        q_params.boost_queries = serde_json::from_str(&el).map_err(|_err| Custom(Status::BadRequest, "wrong format boost_queries".to_string()))?;
        println!("{:?}", q_params.boost_queries);
    }

    let mut request = query_generator::search_query(&persistence, q_params).map_err(|err| Custom(Status::BadRequest, format!("query_generation failed: {:?}", err)))?;

    request.select = query_param_to_vec(params.select);

    debug!("{}", serde_json::to_string(&request).unwrap());
    search_in_persistence(&persistence, request).map_err(search_error_to_rocket_error)
}

// #[post("/<database>/search_smart", format = "application/json", data = "<request>")]
// fn search_post_query_params(database: String, request: Json<QueryParams>) -> Result<SearchResult, Custom<String>> {
//     search_from_query_params(database, request.0)
// }

#[post("/<database>/search_query_params/explain_plan", format = "application/json", data = "<request>")]
fn search_post_query_params_explain(database: String, request: Json<query_generator::SearchQueryGeneratorParameters>) -> Result<String, Custom<String>> {
    let q_params = request.0;
    ensure_database(&database).unwrap();
    let persistence = PERSISTENCES.get(&database).unwrap();

    let mut request = query_generator::search_query(&persistence, q_params.clone()).map_err(|err| Custom(Status::BadRequest, format!("query_generation failed: {:?}", err)))?;

    request.select = query_param_to_vec(q_params.select);

    debug!("{}", serde_json::to_string(&request).unwrap());
    search::explain_plan(request, &persistence).map_err(search_error_to_rocket_error)
}

#[post("/<database>/search_query_params", format = "application/json", data = "<request>")]
fn search_post_query_params(database: String, request: Json<query_generator::SearchQueryGeneratorParameters>) -> Result<SearchResult, Custom<String>> {
    let q_params = request.0;
    ensure_database(&database).unwrap();
    let persistence = PERSISTENCES.get(&database).unwrap();

    let mut request = query_generator::search_query(&persistence, q_params.clone()).map_err(|err| Custom(Status::BadRequest, format!("query_generation failed: {:?}", err)))?;

    request.select = query_param_to_vec(q_params.select);

    debug!("{}", serde_json::to_string(&request).unwrap());
    search_in_persistence(&persistence, request).map_err(search_error_to_rocket_error)
}

// #[get("/<database>/search/explain_plan?<params..>")]
// fn search_get_explain(database: String, params: LenientForm<QueryParams>) -> Result<String, VelociError> {
//     // let params = params.map_err(|err| Custom(Status::BadRequest, format!("{:let params: QueryParams = params.into_inner();?}", err)))?;
//     let params: QueryParams = params.into_inner();

//     let q_params = request.0;
//     let persistence = PERSISTENCES.get(&database).unwrap();

//     let mut request = query_generator::search_query(&persistence, q_params.clone()).map_err(|err| Custom(Status::BadRequest, format!("query_generation failed: {:?}", err)))?;

//     request.select = query_param_to_vec(q_params.select);

//     search::explain_plan(request, &persistence)
// }

#[get("/<database>/search?<params..>")]
fn search_get(database: String, params: LenientForm<QueryParams>) -> Result<SearchResult, Custom<String>> {
    // let params = params.map_err(|err| Custom(Status::BadRequest, format!("{:let params: QueryParams = params.into_inner();?}", err)))?;
    let params: QueryParams = params.into_inner();
    search_from_query_params(database, params)
}

// #[get("/<database>/search_shard?<params..>")]
// fn search_get_shard(database: String, params: LenientForm<QueryParams>) -> Result<SearchResult, VelociError> {
//     let params: QueryParams = params.into_inner();
//     ensure_shard(&database)?;
//     let shard = SHARDS.get(&database).unwrap();

//     let facets: Option<Vec<String>> = query_param_to_vec(params.facets);
//     let stopword_lists: Option<Vec<String>> = query_param_to_vec(params.stopword_lists);
//     let fields: Option<Vec<String>> = query_param_to_vec(params.fields);
//     let boost_fields: HashMap<String, f32> = query_param_to_vec(params.boost_fields)
//         .map(|mkay| {
//             mkay.into_iter()
//                 .map(|el| {
//                     let field_n_boost = el.split("->").collect::<Vec<&str>>();
//                     (field_n_boost[0].to_string(), field_n_boost[1].parse::<f32>().unwrap())
//                 })
//                 .collect()
//         })
//         .unwrap_or(HashMap::default());

//     // let filter_queries = query_param_to_vec(params.filter).map(|mkay| {
//     //         mkay.into_iter()
//     //             .map(|el| {
//     //                 let field_n_term = el.split(":").collect::<Vec<&str>>();
//     //                 let field = field_n_term[0].to_string();
//     //                 let term = field_n_term[1].to_string();
//     //                 search::RequestSearchPart{
//     //                     path:field,
//     //                     terms: vec![term],
//     //                     ..Default::default()
//     //                 }
//     //             })
//     //             .collect::<Vec<_>>()
//     //     });

//     let boost_terms: HashMap<String, f32> = query_param_to_vec(params.boost_terms)
//         .map(|mkay| {
//             mkay.into_iter()
//                 .map(|el| {
//                     let field_n_boost = el.split("->").collect::<Vec<&str>>();
//                     (field_n_boost[0].to_string(), field_n_boost.get(1).map(|el| el.parse::<f32>().unwrap()).unwrap_or(2.0))
//                 })
//                 .collect()
//         })
//         .unwrap_or(HashMap::default());

//     let q_params = query_generator::SearchQueryGeneratorParameters {
//         search_term: params.query.to_string(),
//         top: params.top,
//         skip: params.skip,
//         operator: params.operator,
//         levenshtein: params.levenshtein,
//         levenshtein_auto_limit: params.levenshtein_auto_limit,
//         facetlimit: params.facetlimit,
//         why_found: params.why_found,
//         phrase_pairs: params.phrase_pairs.map(|el| el.to_lowercase() == "true"),
//         text_locality: params.text_locality.map(|el| el.to_lowercase() == "true"),
//         facets: facets,
//         fields: fields,
//         stopword_lists,
//         boost_fields: boost_fields,
//         boost_terms: boost_terms,
//         explain: params.explain.map(|el| el.to_lowercase() == "true"),
//         boost_queries: None,
//         select: None,
//         filter: params.filter,
//     };

//     //TODO enable
//     // if let Some(el) = params.boost_queries {
//     //     q_params.boost_queries = serde_json::from_str(&el).map_err(|_err| Custom(Status::BadRequest, "wrong format boost_queries".to_string()) )?;
//     // }

//     Ok(SearchResult(shard.search_all_shards_from_qp(&q_params, &query_param_to_vec(params.select))?))
// }

fn search_error_to_rocket_error(err: VelociError) -> Custom<String> {
    match err {
        VelociError::StringError(msg) => Custom(Status::BadRequest, msg),
        _ => Custom(Status::InternalServerError, format!("SearchError: {:?}", err)),
    }
}

// ******************************************** PERMISSION CRITICAL START ********************************************
// ******************************************** UPLOAD UPLOAD ********************************************
// #[post("/<database>", data = "<data>")]
// // signature requires the request to have a `Content-Type`
// fn multipart_upload(database: String, cont_type: &ContentType, data: Data) -> Result<String, Custom<String>> {
//     // this and the next check can be implemented as a request guard but it seems like just
//     // more boilerplate than necessary
//     if !cont_type.is_form_data() {
//         return Err(Custom(Status::BadRequest, "Content-Type not multipart/form-data".into()));
//     }

//     let (_, boundary) = cont_type
//         .params()
//         .find(|&(k, _)| k == "boundary")
//         .ok_or_else(|| Custom(Status::BadRequest, "`Content-Type: multipart/form-data` boundary param not provided".into()))?;

//     let resp = process_upload(boundary, data).map_err(search_error_to_rocket_error)?;

//     veloci::create::create_indices_from_str(
//         &mut veloci::persistence::Persistence::create(database.to_string()).unwrap(),
//         &resp.0,
//         &resp.1.unwrap_or("[]".to_string()),
//         None,
//         false,
//     )
//     .unwrap();
//     Ok(format!("created {:?}", &database))
// }

// fn process_upload(boundary: &str, data: Data) -> Result<(String, Option<String>), VelociError> {
//     // let mut out = Vec::new();

//     // saves all fields, any field longer than 10kB goes to a temporary directory
//     // Entries could implement FromData though that would give zero control over
//     // how the files are saved; Multipart would be a good impl candidate though
//     match Multipart::with_body(data.open(), boundary).save().size_limit(500_000_000).temp() {
//         Full(entries) => process_entries(entries),
//         Partial(partial, reason) => {
//             error!("Request partially processed: {:?}", reason);
//             // writeln!(out, "Request partially processed: {:?}", reason)?;
//             // if let Some(field) = partial.partial {
//             //     writeln!(out, "Stopped on field: {:?}", field.source.headers)?;
//             // }

//             process_entries(partial.entries)
//         }
//         Error(e) => return Err(VelociError::Io(e)),
//     }

//     // Ok(out)
// }

// fn process_entries(entries: Entries) -> Result<(String, Option<String>), VelociError> {
//     if entries.fields_count() == 2 {
//         let mut config = String::new();
//         entries
//             .fields
//             .get("config")
//             .ok_or_else(|| VelociError::StringError(format!("expecting content field, but got {:?}", entries.fields.keys().collect::<Vec<_>>())))?[0]
//             .data
//             .readable()?
//             .read_to_string(&mut config)?;

//         let data_reader = entries
//             .fields
//             .get("data")
//             .ok_or_else(|| VelociError::StringError(format!("expecting data field, but got {:?}", entries.fields.keys().collect::<Vec<_>>())))?[0]
//             .data
//             .readable()?;

//         let mut data: Vec<u8> = vec![];
//         veloci::create::convert_any_json_data_to_line_delimited(data_reader, &mut data)?;
//         return Ok((unsafe { String::from_utf8_unchecked(data) }, Some(config)));
//     }

//     let mut data: Vec<u8> = vec![];
//     let data_reader = entries
//         .fields
//         .get("data")
//         .ok_or_else(|| VelociError::StringError(format!("expecting data field, but got {:?}", entries.fields.keys().collect::<Vec<_>>())))?[0]
//         .data
//         .readable()?;
//     veloci::create::convert_any_json_data_to_line_delimited(data_reader, &mut data)?;
//     Ok((unsafe { String::from_utf8_unchecked(data) }, None))
// }

// // #[post("/<database>", data = "<data>", format = "application/json")]
// // fn create_db(database: String, data: rocket::data::Data) -> Result<String, VelociError> {
// //     if PERSISTENCES.contains_key(&database) {
// //         //TODO @BUG @FixMe ERROR OWASP
// //         PERSISTENCES.remove(&database);
// //     }

// //     let mut out: Vec<u8> = vec![];
// //     veloci::create::convert_any_json_data_to_line_delimited(data.open(), &mut out).unwrap();

// //     veloci::create::create_indices_from_str(
// //         &mut veloci::persistence::Persistence::create(database).unwrap(),
// //         unsafe { std::str::from_utf8_unchecked(&out) },
// //         "[]",
// //         None,
// //         false,
// //     )
// //     .unwrap();
// //     Ok("created".to_string())
// // }

// #[delete("/<database>")]
// fn delete_db(database: String) -> Result<String, VelociError> {
//     if PERSISTENCES.contains_key(&database) {
//         PERSISTENCES.remove(&database);
//     }
//     use std::path::Path;
//     if Path::new(&database).exists() {
//         std::fs::remove_dir_all(&database)?; //TODO @BUG @FixMe ERROR OWASP
//     }

//     Ok("deleted".to_string())
// }

#[get("/<database>/inspect/<path>/<id>")]
fn inspect_data(database: String, path: String, id: u64) -> Result<String, VelociError> {
    ensure_database(&database)?;
    let persistence = PERSISTENCES.get(&database).unwrap();
    // persistence.get(path)
    let data = persistence.get_valueid_to_parent(&path)?;
    Ok(serde_json::to_string(&data.get_values(id)).unwrap())
}

// ******************************************** PERMISSION CRITICAL END ********************************************

#[post("/<database>/suggest", format = "application/json", data = "<request>")]
fn suggest_post(database: String, request: Json<search::Request>) -> Json<serde_json::Value> {
    ensure_database(&database).unwrap();
    let persistence = PERSISTENCES.get(&database).unwrap();
    let hits = search_field::suggest_multi(&persistence, request.0).unwrap();
    Json(serde_json::from_str(&serde_json::to_string(&hits).unwrap()).unwrap())
}

#[get("/<database>/suggest?<params..>", format = "application/json")]
fn suggest_get(database: String, params: LenientForm<QueryParams>) -> Result<SuggestResult, VelociError> {
    let params: QueryParams = params.into_inner();
    ensure_database(&database)?;
    let persistence = PERSISTENCES.get(&database).unwrap();

    let fields: Option<Vec<String>> = query_param_to_vec(params.fields);

    let request = query_generator::suggest_query(
        &params.query,
        &persistence,
        params.top,
        params.skip,
        params.levenshtein,
        &fields,
        params.levenshtein_auto_limit,
    )
    .unwrap();

    debug!("{}", serde_json::to_string(&request).unwrap());
    excute_suggest(&persistence, request, false)
}

#[post("/<database>/highlight", format = "application/json", data = "<request>")]
fn highlight_post(database: String, mut request: Json<search::RequestSearchPart>) -> String {
    ensure_database(&database).unwrap();
    let persistence = PERSISTENCES.get(&database).unwrap();
    let hits = search_field::highlight(&persistence, &mut request).unwrap();
    serde_json::to_string(&hits).unwrap()
}

fn rocket() -> rocket::Rocket {
    let default = rocket_cors::CorsOptions::default();
    let cors_options = rocket_cors::Cors::from_options(&default).unwrap();
    //let cors_options = rocket_cors::Cors {
    //allowed_origins: AllowedOrigins::all(),
    //allowed_methods: vec![Method::Get, Method::Post].into_iter().map(From::from).collect(),
    //allowed_headers: AllowedHeaders::all(),
    //allow_credentials: true,
    //..Default::default()
    //};
    rocket::ignite()
        .mount(
            "/",
            routes![
                version,
                // delete_db,
                // create_db,
                // multipart_upload,
                get_doc_for_id_direct,
                get_doc_for_id_tree,
                search_get,
                search_post,
                search_post_query_params,
                search_post_query_params_explain,
                suggest_get,
                // search_get_shard,
                suggest_post,
                highlight_post,
                inspect_data
            ],
        )
        .attach(Gzip)
        .attach(cors_options)
}

fn main() {
    veloci::trace::enable_log();

    for preload_db in std::env::args().skip(1) {
        ensure_database(&preload_db).unwrap();
    }
    // for preload_db in std::env::args().skip(1) {
    //     ensure_shard(&preload_db).unwrap();
    // }

    println!("Starting Server...");
    rocket().launch();
}

pub struct Gzip;
impl fairing::Fairing for Gzip {
    fn on_response(&self, request: &Request, response: &mut Response) {
        use flate2::Compression;
        let headers = request.headers();
        if headers.get("Accept-Encoding").any(|e| e.to_lowercase().contains("gzip")) {
            response.body_bytes().and_then(|body| {
                let mut gz = GzEncoder::new(&body[..], Compression::default());
                let mut buf = Vec::with_capacity(body.len());
                gz.read_to_end(&mut buf)
                    .map(|_| {
                        response.set_sized_body(Cursor::new(buf));
                        response.set_raw_header("Content-Encoding", "gzip");
                    })
                    .map_err(|e| eprintln!("{}", e))
                    .ok()
            });
        }
    }

    fn info(&self) -> fairing::Info {
        fairing::Info {
            name: "Gzip compression",
            kind: fairing::Kind::Response,
        }
    }
}
